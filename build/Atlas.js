/**
 * Modules in this bundle
 * @license
 *
 * @steelydylan/atlasjs:
 *   license: MIT License
 *   homepage: http://horicdesign.com
 *   version: 1.0.1
 *
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Atlas = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var images = [];
var sounds = [];
var svgs = [];
var allLoaded = 0;
var isMobile = function () {
  var userAgent = navigator.userAgent;
  if (userAgent.indexOf('iPhone') > 0 && userAgent.indexOf('iPad') == -1 || userAgent.indexOf('iPod') > 0 || userAgent.indexOf('Android') > 0) {
    return true;
  }
  return false;
}();
var orientation = function (e) {
  var mq = window.matchMedia('(orientation: portrait)');
  var orientation = '';
  if (mq.matches) {
    return 'portrait';
  }
  return 'landscape';
}();
var setKeyState = function setKeyState(ret, e) {
  var which = e.which;
  switch (which) {
    case 13:
      ret.enter = true;
      break;
    case 16:
      ret.shift = true;
      break;
    case 32:
      ret.space = true;
      break;
    case 39:
      // Key[→]
      ret.right = true;
      break;
    case 37:
      // Key[←]
      ret.left = true;
      break;
    case 38:
      // Key[↑]
      ret.up = true;
      break;
    case 40:
      // Key[↓]
      ret.down = true;
      break;
    case 8:
      ret.backspace = true;
      break;
  }
  if (e.metaKey) {
    ret.command = true;
  }
  for (var _i = 0; _i < 26; _i++) {
    if (_i + 65 == which) {
      var chr = String.fromCharCode(_i + 97);
      ret[chr] = true;
      break;
    }
  }
};

var clearKeyState = function clearKeyState(ret) {
  ret.enter = false;
  ret.command = false;
  ret.shift = false;
  ret.space = false;
  ret.right = false;
  ret.left = false;
  ret.up = false;
  ret.down = false;
  ret.backspace = false;
  for (var _i2 = 0; _i2 < 26; _i2++) {
    ret[String.fromCharCode(_i2 + 97)] = false;
  }
};

var keydown = function () {
  var ret = {};
  clearKeyState(ret);
  return ret;
}();

var Tween = function Tween(that, kind, frame) {
  var mover = that.mover;
  var target = mover[mover.length - 1];
  var obj = {};
  if (target && target.and) {
    obj = target;
  }
  obj.time = 0;
  if (frame) {
    obj.frame = frame;
  }
  obj.loop = false;
  obj.and = false;
  obj[kind] = true;
  return obj;
};
/**
 * @class Atlas.Util
 * */

var Util = exports.Util = function () {
  function Util() {
    _classCallCheck(this, Util);

    this.isMobile = isMobile;
    this.orientation = orientation;
    this.eventListener = {};
    this.mover = [];
    this.rot = 0;
    this.moverIndex = 0;
    this.visible = true;
    this.eventEnable = true;
    this.drawMode = 'source-over';
    var eventListener = this.eventListener;
    eventListener.touchStart = false;
    eventListener.touchMove = false;
    eventListener.touchEnd = false;
    eventListener.keyUp = false;
    eventListener.keyDown = false;
    eventListener.multiTouchStart = false;
    eventListener.multiTouchMove = false;
    eventListener.multiTouchEnd = false;
    eventListener.orientationChange = false;
  }

  _createClass(Util, [{
    key: 'tween',
    value: function tween() {
      var mover = this.mover;
      var length = mover.length;
      if (this.moverIndex < length) {
        var obj = mover[this.moverIndex];
        if (obj.animate) {
          this._animate(obj);
        }
        if (obj.moveTo) {
          this._moveTo(obj);
        }
        if (obj.moveBy) {
          this._moveBy(obj);
        }
        if (obj.rotateBy) {
          this._rotateBy(obj);
        }
        if (obj.scaleBy) {
          this._scaleBy(obj);
        }
        if (obj.then) {
          this._then(obj);
        }
        obj.time++;
        if (obj.time >= obj.frame) {
          this.moverIndex++;
          if (this.moverIndex == length) {
            if (obj.loop) {
              this._refresh();
            } else {
              this.stop();
            }
          }
        }
      }
    }
    /**
     * @method isQueEmpty
     * アニメーション用のキューが空かどうかを判定する
     * */

  }, {
    key: 'isQueEmpty',
    value: function isQueEmpty() {
      return !this.mover.length;
    }
  }, {
    key: '_refresh',
    value: function _refresh() {
      this.moverIndex = 0;
      var mover = this.mover;
      for (var _i3 = 0, _n = mover.length; _i3 < _n; _i3++) {
        var obj = mover[_i3];
        if (obj.time) {
          obj.time = 0;
        }
      }
    }
    /**
     * @method moveTo
     * オフジェクトを(x,y)の座標にframeフレームで移動させる
     * @param x {Number}
     * @param y {Number}
     * @param frame {Number}
     * */

  }, {
    key: 'moveTo',
    value: function moveTo(x, y, frame) {
      var obj = Tween(this, 'moveTo', frame);
      obj.toX = x;
      obj.toY = y;
      this.mover.push(obj);
      return this;
    }
  }, {
    key: '_moveTo',
    value: function _moveTo(obj) {
      if (obj.time === 0) {
        obj.diffX = obj.toX - this.x;
        obj.diffY = obj.toY - this.y;
      }
      this.x = obj.toX - obj.diffX * (1 - obj.time / obj.frame);
      this.y = obj.toY - obj.diffY * (1 - obj.time / obj.frame);
    }
    /**
     * @method moveTo
     * 現在の座標位置からframeフレームで(x,y)移動させる
     * @param x {Number}
     * @param y {Number}
     * @param frame {Number}
     * */

  }, {
    key: 'moveBy',
    value: function moveBy(x, y, frame) {
      var obj = Tween(this, 'moveBy', frame);
      obj.diffX = x;
      obj.diffY = y;
      this.mover.push(obj);
      return this;
    }
  }, {
    key: '_moveBy',
    value: function _moveBy(obj) {
      if (obj.time === 0) {
        obj.toX = this.x + obj.diffX;
        obj.toY = this.y + obj.diffY;
      }
      this.x = obj.toX - obj.diffX * (1 - obj.time / obj.frame);
      this.y = obj.toY - obj.diffY * (1 - obj.time / obj.frame);
    }
    /**
     * @method delay
     * アニメーションをframeフレーム待つ
     * @param frame {Number}
     * */

  }, {
    key: 'delay',
    value: function delay(frame) {
      var obj = Tween(this, 'delay', frame);
      this.mover.push(obj);
      return this;
    }
    /**
     * @method and
     * アニメーションを二つ定義する
     * @example
     * sprite.moveBy(100,100,30).and().rotateBy(Math.PI,30);
     * */

  }, {
    key: 'and',
    value: function and() {
      var mover = this.mover;
      var target = mover[mover.length - 1];
      if (target) {
        target.and = true;
      }
      return this;
    }
    /**
     * @method stop
     * アニメーションを中止する
     * */

  }, {
    key: 'stop',
    value: function stop() {
      this.mover = [];
      this.moverIndex = 0;
      return this;
    }
    /**
     * @method loop
     * アニメーションをループする
     * @example loop
     * sprite.moveBy(100,100,30).and().rotateBy(Math.PI,30).loop();
     * */

  }, {
    key: 'loop',
    value: function loop() {
      var obj = this.mover[this.mover.length - 1];
      obj.loop = true;
      return this;
    }
    /**
    * @method rotateBy
    * @param angle {Number}
    * @param frame {Number}
    * frameフレームでangle（ラジアン）回転させる
    * */

  }, {
    key: 'rotateBy',
    value: function rotateBy(angle, frame) {
      var obj = Tween(this, 'rotateBy', frame);
      this.mover.push(obj);
      obj.diffAngle = angle;
      return this;
    }
  }, {
    key: '_rotateBy',
    value: function _rotateBy(obj) {
      if (obj.time === 0) {
        obj.toAngle = this.rot + obj.diffAngle;
      }
      this.rot = obj.toAngle - obj.diffAngle * (1 - obj.time / obj.frame);
    }
    /**
    * @method then
    * アニメーションの途中に関数を実行する
    * */

  }, {
    key: 'then',
    value: function then(fn, frame) {
      var obj = Tween(this, 'then', frame);
      obj.exec = fn;
      this.mover.push(obj);
      return this;
    }
  }, {
    key: '_then',
    value: function _then(obj) {
      obj.exec.call(this);
    }
    /**
     * @method scaleBy
     * @param x Number
     * @param y Number
     * @param frame Number
     * frameフレームで横にx倍、縦にy倍拡大する
     * */

  }, {
    key: 'scaleBy',
    value: function scaleBy(x, y, frame) {
      var obj = Tween(this, 'scaleBy', frame);
      obj.scaleX = x;
      obj.scaleY = y;
      this.mover.push(obj);
      return this;
    }
    /**
     * @method setPosition
     * @param x Number
     * @param y Number
     * オフジェクトを座標(x,y)に移動
     * */

  }, {
    key: 'setPosition',
    value: function setPosition(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
  }, {
    key: 'saveData',
    value: function saveData(key) {
      var obj = {};
      for (var _i4 in this) {
        if (typeof this[_i4] !== 'function') {
          obj[_i4] = this[_i4];
        }
      }
      localStorage.setItem(key, JSON.stringify(obj));
    }
  }, {
    key: 'getData',
    value: function getData(key) {
      var obj = JSON.parse(localStorage.getItem(key));
      for (var _i5 in obj) {
        this[_i5] = obj[_i5];
      }
    }
    /**
     * @method getTouchPosition
     * @param e eventオブジェクト
     * @param num Number
     * eventオブジェクトからキャンバスの押された位置座標を取得
     * */

  }, {
    key: 'getTouchPosition',
    value: function getTouchPosition(e, num) {
      if (!(num && e.touches[num])) {
        num = 0;
      }
      var field = this.field;
      var rateX = parseInt(field.width) / parseInt(field.style.width);
      var rateY = parseInt(field.height) / parseInt(field.style.height);
      var obj = {};
      var margin = field.getBoundingClientRect();
      var x = parseInt(margin.left);
      var y = parseInt(margin.top);
      if (isNaN(x)) {
        x = 0;
      }
      if (isNaN(y)) {
        y = 0;
      }
      var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
      var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
      if (e) {
        if (!isMobile || isMobile && e.touches[num]) {
          obj.x = (isMobile ? e.touches[num].pageX : e.pageX) - x - scrollX;
          obj.y = (isMobile ? e.touches[num].pageY : e.pageY) - y - scrollY;
        } else {
          obj.x = -1;
          obj.y = -1;
        }
      } else {
        obj.x = event.x - x;
        obj.y = event.y - y;
      }
      obj.x = parseInt(obj.x * rateX);
      obj.y = parseInt(obj.y * rateY);
      return obj;
    }
  }, {
    key: 'getMultiTouchPosition',
    value: function getMultiTouchPosition(e) {
      var length = e.touches.length;
      var pos = [];
      for (var _i6 = 0; _i6 < length; _i6++) {
        pos[_i6] = this.getTouchPosition(e, _i6);
      }
      return pos;
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(e) {
      if (this.eventEnable) {
        e.preventDefault();
        var pos = this.getTouchPosition(e);
        if (e.touches) {
          pos.touchCount = e.touches.length;
        } else {
          pos.touchCount = 1;
        }
        pos.event = e;
        var type = e.type;
        switch (type) {
          case 'touchstart':
            if (this.multiTouchStart && e.touches.length > 1) {
              this.multiTouchStart(this.getMultiTouchPosition(e));
            } else if (this.touchStart) {
              this.touchStart(pos);
            }
            break;
          case 'mousedown':
            if (this.touchStart) this.touchStart(pos);break;
          case 'touchmove':
            if (this.multiTouchMove && e.touches.length > 1) {
              this.multiTouchMove(this.getMultiTouchPosition(e));
            } else if (this.touchMove) {
              this.touchMove(pos);
            }
            break;
          case 'mousemove':
            if (this.touchMove) this.touchMove(pos);break;
          case 'touchend':
            if (this.multiTouchEnd && e.touches.length > 1) {
              this.multiTouchEnd(this.getMultiTouchPosition(e));
            } else if (this.touchEnd) {
              this.touchEnd(pos);
            }
            break;
          case 'mouseup':
            if (this.touchEnd) this.touchEnd();break;
          case 'keydown':
            if (this.keyDown) this.keyDown(keydown);break;
          case 'keyup':
            if (this.keyUp) this.keyUp();break;
        }
      }
    }
  }, {
    key: 'useEvent',
    value: function useEvent() {
      var field = this.field;
      var eventListener = this.eventListener;
      if (this.touchStart && eventListener.touchStart === false) {
        if (isMobile) {
          field.addEventListener('touchstart', this, false);
        } else {
          field.addEventListener('mousedown', this, false);
        }
        eventListener.touchStart = true;
      }
      if (this.touchMove && eventListener.touchMove === false) {
        if (isMobile) {
          field.addEventListener('touchmove', this, false);
        } else {
          field.addEventListener('mousemove', this, false);
        }
        eventListener.touchMove = true;
      }
      if (this.touchEnd && eventListener.touchEnd === false) {
        if (isMobile) {
          field.addEventListener('touchend', this, false);
        } else {
          field.addEventListener('mouseup', this, false);
        }
        eventListener.touchEnd = true;
      }
      if (this.multiTouchStart && eventListener.multiTouchStart === false) {
        if (!eventListener.touchStart) {
          if (isMobile) {
            field.addEventListener('touchstart', this, false);
          } else {
            field.addEventListener('mousedown', this, false);
          }
        }
        eventListener.touchStart = true;
      }
      if (this.multiTouchMove && eventListener.multiTouchMove === false) {
        if (!eventListener.touchMove) {
          if (isMobile) {
            field.addEventListener('touchmove', this, false);
          } else {
            field.addEventListener('mousemove', this, false);
          }
        }
        eventListener.touchMove = true;
      }
      if (this.multiTouchEnd && eventListener.multiTouchEnd === false) {
        if (!eventListener.touchEnd) {
          if (isMobile) {
            field.addEventListener('touchend', this, false);
          } else {
            field.addEventListener('mouseup', this, false);
          }
        }
        eventListener.touchEnd = true;
      }
      if (this.keyUp && eventListener.keyUp === false) {
        field.addEventListener('keyup', this, false);
        eventListener.keyUp = true;
      }
      if (this.keyDown && eventListener.keyDown === false) {
        field.addEventListener('keydown', this, false);
        eventListener.keyDown = true;
      }
    }
    /**
     * @method remove
     * オブジェクトをゲームから除外
     * */

  }, {
    key: 'remove',
    value: function remove() {
      this._remove = true;
    }
    /**
     * @method leave
     * オブジェクトをAppインスタンスやLayerインスタンスから引き離す
     * */

  }, {
    key: 'leave',
    value: function leave() {
      this._leave = true;
    }
    /**
     * @method getRand
     * @param a Number
     * @param b Number
     * a ~ bの間のランダムな数字を取得
     * */

  }, {
    key: 'getRand',
    value: function getRand(a, b) {
      return ~~(Math.random() * (b - a + 1)) + a;
    }
    /**
     * @method getRandText
     * @param limit Number
     * limitまでの文字数で文字列を取得
     * */

  }, {
    key: 'getRandText',
    value: function getRandText(limit) {
      var ret = '';
      var strings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      var length = strings.length;
      for (var _i7 = 0; _i7 < limit; _i7++) {
        ret += strings.charAt(Math.floor(this.getRand(0, length)));
      }
      return ret;
    }
    /**
     * @method rgbToHex
     * @param r Number
     * @param g Number
     * @param b Number
     * RGB形式から16進を取得する
     * */

  }, {
    key: 'rgbToHex',
    value: function rgbToHex(r, g, b) {
      var rgb = b | g << 8 | r << 16;
      return '#' + (0x1000000 + rgb).toString(16).slice(1);
    }
    /**
     * @method hexToRgb
     * @param color String
     * @param opacity Number
     * 16進からRGBを取得する
     * */

  }, {
    key: 'hexToRgb',
    value: function hexToRgb(color, opacity) {
      if ((typeof color === 'undefined' ? 'undefined' : _typeof(color)) === Number) {
        opacity = color;
        color = null;
      }
      var hex = color || this.color;
      var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (opacity) {
        return result ? 'rgba(' + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16) + ',' + opacity + ')' : null;
      }
      return result ? 'rgb(' + parseInt(result[1], 16) + ',' + parseInt(result[2], 16) + ',' + parseInt(result[3], 16) + ')' : null;
    }
    /**
     * @method hsbToHex
     * @param h Number
     * @param s Number
     * @param v Number
     * hsvから16進に変換する
     * */

  }, {
    key: 'hsvToHex',
    value: function hsvToHex(h, s, v) {
      var f = void 0,
          i = void 0,
          p = void 0,
          q = void 0,
          t = void 0;
      var r = void 0,
          g = void 0,
          b = void 0;
      i = Math.floor(h / 60.0) % 6;
      f = h / 60.0 - Math.floor(h / 60.0);
      p = Math.round(v * (1.0 - s / 255.0));
      q = Math.round(v * (1.0 - s / 255.0 * f));
      t = Math.round(v * (1.0 - s / 255.0 * (1.0 - f)));
      switch (i) {
        case 0:
          r = v;g = t;b = p;break;
        case 1:
          r = q;g = v;b = p;break;
        case 2:
          r = p;g = v;b = t;break;
        case 3:
          r = p;g = q;b = v;break;
        case 4:
          r = t;g = p;b = v;break;
        case 5:
          r = v;g = p;b = q;break;
      }
      if (r <= 15) {
        r = '0' + r.toString(16);
      } else {
        r = r.toString(16);
      }
      if (g <= 15) {
        g = '0' + g.toString(16);
      } else {
        g = g.toString(16);
      }
      if (b <= 15) {
        b = '0' + b.toString(16);
      } else {
        b = b.toString(16);
      }
      return '#' + r + g + b;
    }
  }, {
    key: 'rgbToHsv',
    value: function rgbToHsv(r, g, b) {
      var rr = void 0,
          gg = void 0,
          bb = void 0;
      var r = r / 255;
      var g = g / 255;
      var b = b / 255;
      var h = void 0,
          s = void 0,
          v = void 0;
      v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      if (diff == 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rr = (v - r) / 6 / diff + 1 / 2;
        gg = (v - g) / 6 / diff + 1 / 2;
        bb = (v - b) / 6 / diff + 1 / 2;
        if (r === v) {
          h = bb - gg;
        } else if (g === v) {
          h = 1 / 3 + rr - bb;
        } else if (b === v) {
          h = 2 / 3 + gg - rr;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return 'hsv(' + Math.round(h * 360) + ',' + Math.round(s * 100) + ',' + Math.round(v * 100) + ')';
    }
  }, {
    key: 'hexToHsv',
    value: function hexToHsv(color) {
      var rgb = this.hexToRgb(color);
    }
  }, {
    key: 'getObjFromRgb',
    value: function getObjFromRgb(color) {
      var arr = /rgb\((.*?),(.*?),(.*?)\)/.exec(color);
      return {
        r: parseInt(arr[1]),
        g: parseInt(arr[2]),
        b: parseInt(arr[3])
      };
    }
  }, {
    key: 'getObjFromHsv',
    value: function getObjFromHsv(color) {
      var arr = /hsv\((.*?),(.*?),(.*?)\)/.exec(color);
      return {
        h: parseInt(arr[1]),
        s: parseInt(arr[2]),
        v: parseInt(arr[3])
      };
    }
    /**
     * @method getSound
     * @param name String
     * Appインスタンスにロードされた音楽を取得する
     * */

  }, {
    key: 'getSound',
    value: function getSound(name) {
      for (var _i8 = 0, _n2 = sounds.length; _i8 < _n2; _i8++) {
        if (name == sounds[_i8].name) {
          this.sound = new Audio(sounds[_i8].src);
        }
      }
    }
    /**
     * @method soundClonePlay
     * セットされた音楽を複製して再生する
     * */

  }, {
    key: 'soundClonePlay',
    value: function soundClonePlay() {
      var sound = this.sound;
      if (sound) {
        new Audio(sound.src).play();
      }
    }
    /**
     * @method soundLoopPlay
     * セットされた音楽をループ再生する
     * */

  }, {
    key: 'soundLoopPlay',
    value: function soundLoopPlay() {
      var sound = this.sound;
      if (sound) {
        if (!sound.loop) {
          sound.addEventListener('ended', function () {
            this.currentTime = 0;
            this.play();
          }, false);
        }
        sound.loop = true;
        sound.play();
      }
    }
    /**
     * @method soundReplay
     * 再生中の音楽をはじめから再生する
     * */

  }, {
    key: 'soundReplay',
    value: function soundReplay() {
      var sound = this.sound;
      if (sound) {
        sound.load();
        sound.play();
      }
    }
    /**
     * @method soundStop
     * 再生中の音楽を停止する
     * */

  }, {
    key: 'soundStop',
    value: function soundStop() {
      var sound = this.sound;
      if (!sound.paused) {
        sound.pause();
        sound.currentTime = 0;
      } else {
        sound.load();
      }
    }
    /**
     * @method soundPlay
     * セットされた音楽を再生する
     * */

  }, {
    key: 'soundPlay',
    value: function soundPlay() {
      var sound = this.sound;
      if (sound) {
        sound.play();
      }
    }
    /**
     * @method soundPause
     * 再生中の音楽を一時停止する
     * */

  }, {
    key: 'soundPause',
    value: function soundPause() {
      var sound = this.sound;
      if (sound) {
        sound.pause();
      }
    }
    /**
     * @method soundGetCount
     * 再生中の音楽の再生位置を取得する
     * */

  }, {
    key: 'soundGetCount',
    value: function soundGetCount() {
      var sound = this.sound;
      if (sound) {
        return sound.currentTime;
      }
    }
    /**
     * @method soundSetCount
     * @param time Number
     * 指定された位置に再生位置を設定する
     * */

  }, {
    key: 'soundSetCount',
    value: function soundSetCount(time) {
      var sound = this.sound;
      if (sound) {
        sound.currentTime = time;
      }
    }
    /**
     * @method soundGetVolume
     * セットされた音楽のボリュームを取得する
     * */

  }, {
    key: 'soundGetVolume',
    value: function soundGetVolume() {
      var sound = this.sound;
      if (sound) {
        return sound.volume;
      }
    }
    /**
     * @method soundSetVolume
     * @param volume Number
     * セットされた音楽のボリュームを設定する
     * */

  }, {
    key: 'soundSetVolume',
    value: function soundSetVolume(volume) {
      var sound = this.sound;
      if (sound) {
        sound.volume = volume;
      }
    }
    /**
     * @method soundGetAlltime
     * 全再生時間を取得する
     * */

  }, {
    key: 'soundGetAlltime',
    value: function soundGetAlltime() {
      var sound = this.sound;
      if (sound) {
        return sound.duration;
      }
    }
    /**
     * @method 音楽が再生中かを調べる
     * @return Boolean
     * */

  }, {
    key: 'soundIsPlaying',
    value: function soundIsPlaying() {
      var sound = this.sound;
      if (sound) {
        return !sound.paused;
      }
    }
    /**
     * @method getExtention
     * @param fileName String
     * ファイル名から拡張子を取得する
     * */

  }, {
    key: 'getExtention',
    value: function getExtention(fileName) {
      var ret = void 0;
      if (!fileName) {
        return ret;
      }
      var fileTypes = fileName.split('.');
      var len = fileTypes.length;
      if (len === 0) {
        return ret;
      }
      ret = fileTypes[len - 1];
      return ret;
    }
  }]);

  return Util;
}();
/**
 * @class Atlas.App
 * @extends Atlas.Util
 * */


var App = exports.App = function (_Util) {
  _inherits(App, _Util);

  function App(place) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this));

    _this.assetPath = '';
    _this._basicConstructor = 'App';
    var css = document.createElement('style');
    css.media = 'screen';
    css.type = 'text/css';
    document.getElementsByTagName('head')[0].appendChild(css);
    var field = void 0;
    if (place) {
      field = document.getElementById(place);
    } else {
      field = document.createElement('canvas');
      var Body = document.getElementsByTagName('body').item(0);
      Body.appendChild(field);
    }
    field.width = 320;
    field.height = 480;
    field.style.top = 0 + 'px';
    field.style.left = 0 + 'px';
    field.tabIndex = '1';
    document.body.style.margin = '0em';
    var userAgent = navigator.userAgent;
    if (isMobile) {
      field.style.width = window.innerWidth + 'px'; // mobile default
      field.style.height = window.innerHeight + 'px'; // mobile default
      field.addEventListener('touchstart', function () {
        if (this.tabIndex != -1) this.focus();
      });
    } else {
      field.style.width = 480 + 'px';
      field.style.height = 620 + 'px';
      field.addEventListener('mousedown', function () {
        if (this.tabIndex != -1) this.focus();
      });
      field.addEventListener('keyup', function () {
        clearKeyState(keydown);
      }, false);
      field.addEventListener('keydown', function (e) {
        setKeyState(keydown, e);
      });
    }
    _this._css = css;
    _this.field = field;
    _this.ctx = field.getContext('2d');
    _this.fps = 30; // fps default
    _this.scene = new Scene();
    _this.scene.ctx = _this.ctx;
    _this.scene.field = _this.field;
    _this.scene.parent = _this;
    return _this;
  }
  /**
   * @method clearLockMode
   * ゲーム画面のタブインデントを解除する
   * */


  _createClass(App, [{
    key: 'clearLockMode',
    value: function clearLockMode() {
      this.field.tabIndex = '-1';
    }
    /**
     * @method setLockMode
     * ゲーム画面のタブインデントを有効にする
     * */

  }, {
    key: 'setLockMode',
    value: function setLockMode() {
      this.field.tabIndex = '1';
    }
    /**
     * @method getCanvasURL
     * ゲーム画面のデータURLを取得
     * */

  }, {
    key: 'getCanvasURL',
    value: function getCanvasURL() {
      return this.field.toDataURL();
    }
    /**
     * @method getCanvasImage
     * キャンバス画面の画像を新しいタブで開く
     * */

  }, {
    key: 'getCanvasImage',
    value: function getCanvasImage() {
      var url = this.field.toDataURL();
      window.open(url, '_blank');
    }
    /**
     * @method getChild
     * ゲームに登録されたプロパティの一致するオブジェクトを取得する
     * */

  }, {
    key: 'getChild',
    value: function getChild(obj) {
      return this.scene.getChild(obj);
    }
    /**
     * @method getChildren
     * ゲームに登録されたプロパティの一致するオブジェクトをすべて取得する
     * */

  }, {
    key: 'getChildren',
    value: function getChildren(obj) {
      return this.scene.getChildren(obj);
    }
    /**
     * @method colorToAlpha
     * ゲームに登録された画像の指定された色を透明にする
     * */

  }, {
    key: 'colorToAlpha',
    value: function colorToAlpha(imagename, hex) {
      var img = void 0;
      for (var _i9 = 0, _n3 = images.length; _i9 < _n3; _i9++) {
        if (images[_i9].name == imagename) {
          img = images[_i9];
          img.hex = hex;
          img.index = _i9;
        }
      }
      img.addEventListener('load', function () {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var width = this.width;
        var height = this.height;
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        var hex = this.hex.replace(shorthandRegex, function (m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        var color = result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
        ctx.drawImage(this, 0, 0);
        var ImageData = ctx.getImageData(0, 0, width, height);
        var data = ImageData.data;
        for (var _i10 = 0; _i10 < height; _i10++) {
          for (var j = 0; j < width; j++) {
            var t = _i10 * (width * 4) + j * 4;
            if (data[t] == color.r && data[t + 1] == color.g && data[t + 2] == color.b) {
              data[t + 3] = 0;
            }
          }
        }
        ctx.putImageData(ImageData, 0, 0); // put image data back
        var newimg = new Image();
        newimg.src = canvas.toDataURL();
        images[this.index] = newimg;
      });
    }
    /**
     * @method addChild
     * @param child
     * ゲームにオブジェクトを登録する
     * */

  }, {
    key: 'addChild',
    value: function addChild(child) {
      child.ctx = this.ctx;
      child.field = this.field;
      this.scene.addChild(child);
    }
    /**
     * @method addChildren
     * ゲームにオブジェクトを複数登録する
     * */

  }, {
    key: 'addChildren',
    value: function addChildren() {
      for (var _i11 = 0, _n4 = arguments.length; _i11 < _n4; _i11++) {
        this.addChild(arguments[_i11]);
      }
    }
    /**
     * @method centerize
     * ゲーム画面を画面の中央に配置する
     * */

  }, {
    key: 'centerize',
    value: function centerize() {
      var style = this.field.style;
      style.marginTop = -parseInt(style.height) / 2 + 'px';
      style.marginLeft = -parseInt(style.width) / 2 + 'px';
      style.top = '50%';
      style.left = '50%';
      style.position = 'absolute';
    }
    /**
     * @method fitWindow
     * ゲーム画面をウィンドウにフィットさせる
     * */

  }, {
    key: 'fitWindow',
    value: function fitWindow() {
      this.setSize(window.innerWidth, window.innerHeight);
      var that = this;
      window.onresize = function () {
        that.setSize(window.innerWidth, window.innerHeight);
      };
    }
    /**
     * @method setQuality
     * @param width Number
     * @param height Number
     * ゲーム画面の解像度を設定する
     * */

  }, {
    key: 'setQuality',
    value: function setQuality(width, height) {
      var field = this.field;
      field.width = width;
      field.height = height;
    }
    /**
     * @method setSize
     * @param width Number
     * @param height Number
     * ゲーム画面の大きさを設定する
     * */

  }, {
    key: 'setSize',
    value: function setSize(width, height) {
      var style = this.field.style;
      style.width = width + 'px';
      style.height = height + 'px';
    }
    /**
    * @method getSize
    * ゲーム画面の大きさを取得する
    * */

  }, {
    key: 'getSize',
    value: function getSize() {
      var size = {};
      size.width = parseInt(this.field.style.width);
      size.height = parseInt(this.field.style.height);
      return size;
    }
    /**
     * @method getQuality
     * ゲーム画面の解像度を取得する
     * */

  }, {
    key: 'getQuality',
    value: function getQuality() {
      var size = {};
      size.width = parseInt(this.field.width);
      size.height = parseInt(this.field.height);
      return size;
    }
    /**
     * @method loadingScene
     * @param scene Sceneオブジェクト
     * ローディング中のシーンを登録する
     * */

  }, {
    key: 'loadingScene',
    value: function loadingScene(scene) {
      this.preScene = scene;
      this.preScene.parent = this;
    }
  }, {
    key: '_preLoadEnterFrame',
    value: function _preLoadEnterFrame() {
      var field = this.field;
      this.useEvent();
      var ctx = this.ctx;
      ctx.clearRect(0, 0, field.width, field.height);
      if (allLoaded > 0) {
        if (this.preScene) {
          this.preScene._enterFrame();
        }
      } else {
        if (this.onLoad) {
          this.onLoad();
        }
        var children = this.scene.children;
        for (var _i12 = 0, _n5 = children.length; _i12 < _n5; _i12++) {
          var child = children[_i12];
          if (child._onLoad) {
            child._onLoad();
          } // システム用
          if (child.onLoad) {
            child.onLoad();
          } // フック用
        }
        clearInterval(this.preLoadInterval);
        var that = this;
        setInterval(function () {
          that._enterFrame();
        }, 1000 / this.fps);
      }
    }
  }, {
    key: '_enterFrame',
    value: function _enterFrame() {
      var field = this.field;
      this.ctx.clearRect(0, 0, field.width, field.height);
      this.useEvent();
      if (this.enterFrame) {
        this.enterFrame();
      }
      this.scene._enterFrame();
    }
    /**
     * @method pushScene
     * @param scene Sceneオブジェクト
     * 現在のシーンを新しいシーンに置き換える
     * */

  }, {
    key: 'pushScene',
    value: function pushScene(scene) {
      var ctx = this.ctx;
      var field = this.field;
      var children = this.scene.children;
      for (var _i13 = 0, _n6 = children.length; _i13 < _n6; _i13++) {
        var target = children[_i13];
        target.eventEnable = false;
        if (target.onSceneremoved) {
          target.onSceneRemoved();
        }
      }
      children = scene.children;
      for (i = 0, n = children.length; i < n; i++) {
        var obj = children[i];
        obj.ctx = ctx;
        obj.field = field;
        obj.eventEnable = true;
        if (obj.onScenePushed) {
          obj.onScenePushed();
        }
      }
      scene.parent = this;
      scene.ctx = ctx;
      scene.field = field;
      var style = this.field.style;
      style.background = null;
      style.backgroundColor = 'white';
      if (scene.color) {
        this.setColor(scene.color);
      }
      if (scene.image) {
        this.setImage(scene.image);
      }
      this.scene = scene;
    }
    /**
     * @method setColor
     * @param color String
     * ゲームの背景色を設定する
     * */

  }, {
    key: 'setColor',
    value: function setColor(color) {
      var style = this.field.style;
      style.background = null;
      style.backgroundColor = color;
    }
    /**
     * @method setImage
     * @param img String
     * ゲームの背景画像を設定する
     * */

  }, {
    key: 'setImage',
    value: function setImage(img) {
      var style = this.field.style;
      style.background = 'url(' + img + ') no-repeat center';
      style.backgroundSize = 'cover';
    }
    /**
     * @method start
     * ゲームをスタートする
     * */

  }, {
    key: 'start',
    value: function start() {
      var field = this.field;
      var that = this;
      this.ctx.clearRect(0, 0, field.width, field.height);
      this.preLoadInterval = setInterval(function () {
        that._preLoadEnterFrame();
      }, 1000 / this.fps);
    }
    /**
     * @method load
     * 音楽や画像等の素材をロードする
     * */

  }, {
    key: 'load',
    value: function load() {
      var musicLoaded = function musicLoaded() {
        allLoaded--;
        console.log(this.src + ' is loaded');
      };
      var svgLoaded = function svgLoaded() {
        allLoaded--;
        this.style.display = 'none';
        this.loaded = true;
        console.log(this.data + ' is loaded');
      };
      var imgLoaded = function imgLoaded() {
        allLoaded--;
        this.loaded = true;
        console.log(this.src + ' is loaded');
      };
      for (var _i14 = 0, _n7 = arguments.length; _i14 < _n7; _i14++) {
        var obj = arguments[_i14];
        var data = obj;
        var name = obj;
        if (obj instanceof Array) {
          var data = obj[0];
          var name = obj[1];
        }
        if (data.match('data:image/png')) {
          var ext = 'png';
        } else {
          if (this.assetPath) {
            data = '' + this.assetPath + data;
          }
          var ext = this.getExtention(data);
        }
        if (ext == 'wav' || ext == 'mp3' || ext == 'ogg') {
          var obj = new Audio(data);
          obj.name = name;
          allLoaded++;
          obj.addEventListener('canplaythrough', musicLoaded);
          sounds.push(obj);
        } else if (ext == 'TTF' || ext == 'ttf') {
          var css = this._css;
          var rule = document.createTextNode('' + ('@font-face{' + "font-family:'") + name + '\';' + ('src: url(\'' + data + '\') format(\'truetype\');') + '}');
          if (css.styleSheet) {
            css.styleSheet.cssText = rule;
          } else {
            css.appendChild(rule);
          }
        } else if (ext == 'svg') {
          var obj = document.createElement('object');
          obj.addEventListener('load', svgLoaded);
          obj.data = data;
          obj.name = name;
          document.body.appendChild(obj);
          allLoaded++;
          svgs.push(obj);
        } else if (ext == 'png' || ext == 'gif' || ext == 'jpeg' || ext == 'jpg') {
          var obj = new Image();
          obj.addEventListener('load', imgLoaded);
          obj.src = data;
          obj.name = name;
          allLoaded++;
          images.push(obj);
        }
      }
    }
  }]);

  return App;
}(Util);
/**
 * @class Atlas.Thing
 * @extends Atlas.Util
 * */


var Thing = exports.Thing = function (_Util2) {
  _inherits(Thing, _Util2);

  function Thing(width, height) {
    _classCallCheck(this, Thing);

    var _this2 = _possibleConstructorReturn(this, (Thing.__proto__ || Object.getPrototypeOf(Thing)).call(this));

    _this2.x = 0;
    _this2.y = 0;
    _this2._remove = false;
    _this2.width = width;
    _this2.height = height;
    _this2.collisionShape = 'box';
    _this2.prepared = false; /* 描画の準備が完了 */
    _this2.alpha = 1;
    return _this2;
  }

  _createClass(Thing, [{
    key: '_scaleBy',
    value: function _scaleBy(obj) {
      if (obj.time === 0) {
        obj.toWidth = this.width * obj.scaleX;
        obj.toHeight = this.height * obj.scaleY;
        obj.diffWidth = obj.toWidth - this.width;
        obj.diffHeight = obj.toHeight - this.height;
      }
      this.width = obj.toWidth - obj.diffWidth * (1 - obj.time / obj.frame);
      this.height = obj.toHeight - obj.diffHeight * (1 - obj.time / obj.frame);
    }
    /**
     * @method intersect
     * @param ex Number
     * @param ey Number
     * 座標(ex,ey)にオブジェクトが衝突しているかを判定する
     * */

  }, {
    key: 'intersect',
    value: function intersect(ex, ey) {
      var thisx = this._x || this.x;
      var thisy = this._y || this.y;
      var thisw = this._width || this.width;
      var thish = this._height || this.height;
      var r = this._rot || this.rot;
      if (this.collisionShape == 'box') {
        var x = ex - (thisx + thisw / 2);
        var y = ey - (thisy + thish / 2);
        var s = Math.sin(-r);
        var c = Math.cos(-r);
        var xx = Math.abs(x * c - y * s);
        var yy = Math.abs(x * s + y * c);
        if (xx < thisw / 2.0 && yy < thish / 2.0) {
          return true;
        }
        return false;
      } else if (this.collisionShape == 'circle') {
        var radius = thisw / 2;
        var x = ex - (thisx + radius);
        var y = ey - (thisy + radius);
        if (Math.sqrt(x * x + y * y) < radius) {
          return true;
        }
        return false;
      }
      return false;
    }
    /**
     * @method hitTest
     * @param target Thingオブジェクト
     * 自分がターゲットと接触しているかを判定する
     * */

  }, {
    key: 'hitTest',
    value: function hitTest(target) {
      /* 衝突判定（自分の矩形は傾いてないものとする） */
      var thisx = this._x || this.x;
      var thisy = this._y || this.y;
      var thisW = this._width || this.width;
      var thisH = this._height || this.height;
      var thiscX = thisx + thisW / 2;
      var thiscY = thisy + thisH / 2;
      var targetx = target._x || target.x;
      var targety = target._y || target.y;
      var targetW = target._width || target.width;
      var targetH = target._height || target.height;
      var targetr = target._rot || target.rot;
      if (this.collisionShape == 'box') {
        if (target.collisionShape == 'circle') {
          return target.within(this, targetW / 2);
        } /* 矩形と円の当たり判定ならwithinで実装済み */
      } else if (this.collisionShape == 'circle') {
        return this.within(target, thisW / 2); /* 矩形と円の当たり判定ならwithinで実装済み */
      } else {
        return false;
      }
      if (targetr !== 0 && targetr != Math.PI) {
        if (target.collisionShape == 'box') {
          var centerX = targetx + targetW / 2;
          var centerY = targety + targetH / 2;
          var rot = -targetr;
          thiscX = Math.cos(rot) * (thiscX - centerX) - Math.sin(rot) * (thiscY - centerY) + centerX;
          thiscY = Math.sin(rot) * (thiscX - centerX) + Math.cos(rot) * (thiscY - centerY) + centerY;
          thisx = thiscX - thisW / 2;
          thisy = thiscY - thisH / 2;
        }
      }
      return thisx < targetx + targetW && targetx < thisx + thisW && thisy < targety + targetH && targety < thisy + thisH;
    }
    /**
     * @method within
     * @param target Thingクラス
     * @param range Number
     * 自分がターゲットから半径range以内にいるかどうかを判定する
     * */

  }, {
    key: 'within',
    value: function within(target, range) {
      var thisx = this._x || this.x;
      var thisy = this._y || this.y;
      var thisw = this._width || this.width;
      var thish = this._height || this.height;
      var thisr = this._rot || this.rot;
      var targetx = target._x || target.x;
      var targety = target._y || target.y;
      var targetw = target._width || target.width;
      var targeth = target._height || target.height;
      var targetr = target._rot || target.rot;
      if (this.collisionShape == 'box') {
        var thiscX = thisx + thisw / 2;
        var thiscY = thisy + thish / 2;
      } else if (this.collisionShape == 'circle') {
        var radius = thisw / 2;
        var thiscX = thisx + radius;
        var thiscY = thisy + radius;
      } else {
        return false;
      }
      if (target.collisionShape == 'box') {
        var centerX = targetx + targetw / 2;
        var centerY = targety + targeth / 2;
        var rot = -targetr;
        var cx = Math.cos(rot) * (thiscX - centerX) - Math.sin(rot) * (thiscY - centerY) + centerX;
        var cy = Math.sin(rot) * (thiscX - centerX) + Math.cos(rot) * (thiscY - centerY) + centerY;
        var x, y;
        if (cx < targetx) {
          x = targetx;
        } else if (cx > targetx + targetw) {
          x = targetx + targetw;
        } else {
          x = cx;
        }
        if (cy < targety) {
          y = targety;
        } else if (cy > targety + targeth) {
          y = targety + targeth;
        } else {
          y = cy;
        }
        var a = Math.abs(cx - x);
        var b = Math.abs(cy - y);
      } else if (target.collisionShape == 'circle') {
        var tradius = targetw / 2;
        var x = targetx + tradius;
        var y = targety + tradius;
        var a = Math.abs(thiscX - x);
        var b = Math.abs(thiscY - y);
        range += tradius;
      } else {
        return false;
      }
      if (Math.sqrt(a * a + b * b) < range) {
        return true;
      }
      return false;
    }
    /**
     * @method scale
     * @param sx Number
     * @param sy Number
     * オブジェクトを(sx,sy)倍する
     * */

  }, {
    key: 'scale',
    value: function scale(sx, sy) {
      if (!this.width) {
        this._scaleX = sx;
        this._scaleY = sy;
      } else {
        this.width *= sx;
        this.height *= sy;
      }
      return this;
    }
    /**
     * @method setSize
     * @param w Number
     * @param h Number
     * オブジェクトを幅w、高さhに設定する
     * */

  }, {
    key: 'setSize',
    value: function setSize(w, h) {
      this.width = w;
      this.height = h;
    }
  }]);

  return Thing;
}(Util);
/**
 * @class Atlas.Shape
 * @extends Atlas.Thing
 * SVGを描画するためのクラス
 * */


var Shape = exports.Shape = function (_Thing) {
  _inherits(Shape, _Thing);

  function Shape(path, color, lineColor) {
    _classCallCheck(this, Shape);

    var _this3 = _possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this, 0, 0));

    _this3.obj = -1;
    _this3.svgid = -1;
    _this3._basicConstructor = 'Shape';
    _this3.color = color || 'original';
    _this3.strokeColor = lineColor || 'original';
    _this3.colorStops = [];
    if (_this3.getExtention(path) != 'svg') {
      _this3.svgid = path;
    } else {
      _this3.setImage(path);
    }
    _this3.closeMode = true;
    _this3.strokeMode = true;
    return _this3;
  }
  /**
   * @method setSpriteSize
   * @param width Number
   * @param height Number
   * スプライトの大きさを設定する
   * */


  _createClass(Shape, [{
    key: 'setSpriteSize',
    value: function setSpriteSize(width, height) {
      this.spriteWidth = width;
      this.spriteHeight = height;
    }
    /**
     * @method setImage
     * @param path String
     * ゲームにロードされたSVG画像をロードする
     * */

  }, {
    key: 'setImage',
    value: function setImage(path) {
      for (var _i15 = 0, _n8 = svgs.length; _i15 < _n8; _i15++) {
        if (path == svgs[_i15].name) {
          this.obj = _i15;
        }
      }
    }
    /**
     * @method getImage
     * セットされているSVG画像を取得する
     * */

  }, {
    key: 'getImage',
    value: function getImage() {
      return svgs[this.obj];
    }
    /**
     * @method getImageName
     * セットされている画像名を取得する
     * */

  }, {
    key: 'getImageName',
    value: function getImageName() {
      return svgs[this.obj].data;
    }
    /**
     * @method parsePolygon
     * @param polygon String
     * SVGのポリゴン要素を解析
     * */

  }, {
    key: 'parsePolygon',
    value: function parsePolygon(polygon) {
      var pols = polygon.split(' ');
      var data = [];
      for (var _i16 = 0, _n9 = pols.length - 1; _i16 < _n9; _i16++) {
        var pt = pols[_i16].split(',');
        var x = Number(pt[0]);
        var y = Number(pt[1]);
        var obj = { method: 'lineTo', x: x, y: y };
        data.push(obj);
      }
      return data;
    }
    /**
     * @method parsePath
     * @param path String
     * SVGのpath要素を解析
     * */

  }, {
    key: 'parsePath',
    value: function parsePath(path) {
      /* SVGのpath要素を解析 */
      var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
      var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
      var data = [];
      path.replace(segment, function (_, command, args) {
        var type = command.toLowerCase();
        args = args.match(/-?[.0-9]+(?:e[-+]?\d+)?/ig);
        args = args ? args.map(Number) : [];
        if (type == 'm' && args.length > 2) {
          data.push([command].concat(args.splice(0, 2)));
          type = 'l';
          command = command == 'm' ? 'l' : 'L';
        }
        while (true) {
          if (args.length == length[type]) {
            args.unshift(command);
            if (args[0] == 'q') {
              var obj = { method: 'quadraticCurveBy', cpx: args[1], cpy: args[2], x: args[3], y: args[4] };
            } else if (args[0] == 'Q') {
              var obj = { method: 'quadraticCurveTo', cpx: args[1], cpy: args[2], x: args[3], y: args[4] };
            } else if (args[0] == 'l') {
              var obj = { method: 'lineBy', x: args[1], y: args[2] };
            } else if (args[0] == 'L') {
              var obj = { method: 'lineTo', x: args[1], y: args[2] };
            } else if (args[0] == 'm') {
              var obj = { method: 'moveBy', x: args[1], y: args[2] };
            } else if (args[0] == 'M') {
              var obj = { method: 'moveTo', x: args[1], y: args[2] };
            } else if (args[0] == 'c') {
              var obj = { method: 'bezierCurveBy', cpx1: args[1], cpy1: args[2], cpx2: args[3], cpy2: args[4], x: args[5], y: args[6] };
            } else if (args[0] == 'C') {
              var obj = { method: 'bezierCurveTo', cpx1: args[1], cpy1: args[2], cpx2: args[3], cpy2: args[4], x: args[5], y: args[6] };
            } else if (args[0] == 'h') {
              var obj = { method: 'horizontalBy', x: args[1] };
            } else if (args[0] == 'H') {
              var obj = { method: 'horizontalTo', x: args[1] };
            } else if (args[0] == 'v') {
              var obj = { method: 'verticalBy', y: args[1] };
            } else if (args[0] == 'V') {
              var obj = { method: 'verticalTo', y: args[1] };
            } else if (args[0] == 's') {
              var obj = { method: 'bezierCurveShortBy', cpx2: args[1], cpy2: args[2], x: args[3], y: args[4] };
            } else if (args[0] == 'S') {
              var obj = { method: 'bezierCurveShortTo', cpx2: args[1], cpy2: args[2], x: args[3], y: args[4] };
            } else if (args[0] == 't') {
              var obj = { method: 'quadraticCurveShortBy', x: args[1], y: args[2] };
            } else if (args[0] == 'T') {
              var obj = { method: 'quadraticCurveShortTo', x: args[1], y: args[2] };
            } else {
              var obj = {};
            }
            return data.push(obj);
          }
          data.push([command].concat(args.splice(0, length[type])));
        }
      });
      return data;
    }
    /**
     * @method isLoaded
     * @return Boolean
     * 画像がロードされているかを返す
     * */

  }, {
    key: 'isLoaded',
    value: function isLoaded() {
      var image = this.getImage();
      if (!image) {
        return true;
      }
      if (image.loaded && this.ctx) {
        return true;
      }
      return false;
    }
    /**
     * @method setLinearGradient
     * オブジェクトに対して線形グラデーションを設定する
     * */

  }, {
    key: 'setLinearGradient',
    value: function setLinearGradient(x1, y1, x2, y2) {
      var ctx = this.ctx;
      this.gradientStyle = { x1: x1, y1: y1, x2: x2, y2: y2 };
      this.gradientType = 1;
    }
    /**
     * @method setRadialGradient
     * オブジェクトに対して円形グラデーションを設定する
     * */

  }, {
    key: 'setRadialGradient',
    value: function setRadialGradient(x1, y1, r1, x2, y2, r2) {
      var ctx = this.ctx;
      if (!x2) {
        x2 = x1;
        y2 = y1;
        r2 = r2;
      }
      this.gradientStyle = { x1: x1, y1: y1, r1: r1, x2: x2, y2: y2, r2: r2 };
      this.gradientType = 2;
    }
  }, {
    key: '_addColorStops',
    value: function _addColorStops(stops) {
      var grad = this.color;
      for (var _i17 = 0, _n10 = stops.length; _i17 < _n10; _i17++) {
        var stop = stops[_i17];
        var color = stop.color;
        grad.addColorStop(stop.offset, color);
      }
      this.color = grad;
    }
  }, {
    key: 'setColorStops',
    value: function setColorStops(stops) {
      this.colorStops = stops;
      var style = this.gradientStyle;
      if (this.gradientType == 1) {
        this.color = this.ctx.createLinearGradient(style.x1, style.y1, style.x2, style.y2);
      } else if (this.gradientType == 2) {
        this.color = this.ctx.createRadialGradient(style.x1, style.y1, style.r1, style.x2, style.y2, style.r2);
      }
      this._addColorStops(stops);
    }
  }, {
    key: 'addColorStops',
    value: function addColorStops(stops) {
      for (var _i18 = 0, _n11 = stops.length; _i18 < _n11; _i18++) {
        this.colorStops.push(stops[_i18]);
      }
      this._addColorStops(stops);
    }
  }, {
    key: 'removeColorStopAt',
    value: function removeColorStopAt(num) {
      this.colorStops.splice(num, 1);
      this.setColorStops(this.colorStops);
    }
    /**
     * @method getGradientType
     * 設定されているグラデーションの種類を取得する
     * */

  }, {
    key: 'getGradientType',
    value: function getGradientType() {
      var type = this.gradientType;
      if (type == 1) {
        return 'linear';
      } else if (type == 2) {
        return 'radial';
      }
      return 'single';
    }
  }, {
    key: '_onLoad',
    value: function _onLoad() {
      if (this.obj != -1) {
        var svgdoc = svgs[this.obj].getSVGDocument();
        var element = svgdoc.getElementsByTagName('path')[0] || svgdoc.getElementsByTagName('circle')[0] || svgdoc.getElementsByTagName('rect')[0] || svgdoc.getElementsByTagName('polygon')[0];
        var svg = svgdoc.getElementsByTagName('svg')[0];
      } else {
        var svg = document.getElementById(this.svgid);
        var svgdoc = svg;
        var element = svgdoc.getElementsByTagName('path')[0] || svgdoc.getElementsByTagName('circle')[0] || svgdoc.getElementsByTagName('rect')[0] || svgdoc.getElementsByTagName('polygon')[0];
      }
      var color = svg.getElementsByTagName('linearGradient')[0] || svgdoc.getElementsByTagName('radialGradient')[0];
      if (color) {
        var stopsEle = color.getElementsByTagName('stop');
        var stops = [];
        for (var _i19 = 0, _n12 = stopsEle.length; _i19 < _n12; _i19++) {
          var ele = stopsEle[_i19];
          var obj = {};
          obj.offset = ele.getAttribute('offset');
          var styleCol = ele.style.stopColor.toString();
          var op = ele.style.stopOpacity;
          if (op) {
            styleCol = styleCol.replace('rgb', 'rgba');
            styleCol = styleCol.replace(')', ',' + op + ')');
          }
          obj.color = styleCol;
          stops.push(obj);
        }
        if (color.tagName == 'linearGradient') {
          var x1 = Number(color.getAttribute('x1'));
          var x2 = Number(color.getAttribute('x2'));
          var y1 = Number(color.getAttribute('y1'));
          var y2 = Number(color.getAttribute('y2'));
          this.setLinearGradient(x1, y1, x2, y2);
        } else if (color.tagName == 'radialGradient') {
          var cx = Number(color.getAttribute('cx'));
          var cy = Number(color.getAttribute('cy'));
          var r = Number(color.getAttribute('r'));
          this.setRadialGradient(cx, cy, 0, cx, cy, r);
        }
        this.setColorStops(stops);
      }
      if (this.color == 'original') {
        this.color = element.getAttribute('fill');
      }
      if (this.strokeColor == 'original') {
        this.strokeColor == element.getAttribute('stroke');
      }
      if (element.tagName == 'path') {
        var path = element.getAttribute('d');
        this.path = this.parsePath(path);
      } else if (element.tagName == 'circle') {
        var radius = element.getAttribute('r');
        var array = [];
        array.push({ method: 'circle', r: radius });
        this.path = array;
      } else if (element.tagName == 'polygon') {
        var points = element.getAttribute('points');
        this.path = this.parsePolygon(points);
      } else if (element.tagName == 'rect') {
        var width = element.getAttribute('width');
        var height = element.getAttribute('height');
        var array = [];
        array.push({ method: 'rect', width: width, height: height });
        this.path = array;
      }
      if (this.spriteWidth == void 0) {
        this.spriteWidth = parseInt(svg.getAttribute('width'));
        this.spriteHeight = parseInt(svg.getAttribute('height'));
        if (!this.spriteWidth) {
          var viewBox = svg.getAttribute('viewBox');
          if (viewBox) {
            var data = viewBox.split(' ');
            this.spriteWidth = data[2];
            this.spriteHeight = data[3];
          }
        }
      }
      if (!this.width) {
        this.width = this.spriteWidth;
      }
      if (!this.height) {
        this.height = this.spriteHeight;
      }
      this.prepared = true;
    }
    /**
     * @method draw
     * オブジェクトを描画する
     * */

  }, {
    key: 'draw',
    value: function draw() {
      if (!this.path) {
        this._onLoad();
      }
      var path = this.path;
      var ctx = this.ctx;
      var x = 0;
      var y = 0;
      var tmpx = 0;
      var tmpy = 0;
      var rcpx = 0;
      var rcpy = 0;
      var width = this.width;
      var height = this.height;
      var scaleX = width / this.spriteWidth;
      var scaleY = height / this.spriteHeight;
      var cX = width / 2;
      var cY = height / 2;
      var transX = this._x || this.x;
      var transY = this._y || this.y;
      var rot = this._rot || this.rot;
      ctx.globalAlpha = this.alpha;
      ctx.globalCompositeOperation = this.drawMode;
      ctx.save();
      ctx.translate(transX + cX, transY + cY);
      ctx.rotate(rot);
      ctx.translate(-cX, -cY);
      ctx.scale(scaleX, scaleY);
      ctx.beginPath();
      for (var _i20 = 0, _n13 = path.length; _i20 < _n13; _i20++) {
        var p = this.path[_i20];
        var method = p.method;
        if (method == 'moveTo' || method == 'horizontalTo' || method == 'verticalTo' || method == 'quadraticCurveTo' || method == 'bezierCurveTo' || method == 'lineTo' || method == 'bezierCurveShortTo' || method == 'quadraticCurveShortTo') {
          /* 絶対 */
          tmpx = 0;
          tmpy = 0;
          if (p.x || p.x == 0) {
            x = p.x;
          }
          if (p.y || p.y == 0) {
            y = p.y;
          }
        } else {
          /* 相対 */
          tmpx = x;
          tmpy = y;
          if (p.x) {
            x += p.x;
          }
          if (p.y) {
            y += p.y;
          }
        }
        if (method == 'circle') {
          var r = p.r;
          ctx.arc(x + r, y + r, r, 0, Math.PI * 2, false);
        } else if (method == 'rect') {
          ctx.fillRect(x, y, p.width, p.height);
        } else if (method == 'moveTo' || method == 'moveBy') {
          ctx.moveTo(x, y);
        } else if (method == 'lineTo' || method == 'lineBy') {
          ctx.lineTo(x, y);
        } else if (method == 'quadraticCurveBy' || method == 'quadraticCurveTo') {
          ctx.quadraticCurveTo(tmpx + p.cpx, tmpy + p.cpy, x, y);
          rcpx = 2 * x - (tmpx + p.cpx);
          rcpy = 2 * y - (tmpy + p.cpy);
        } else if (method == 'bezierCurveTo' || method == 'bezierCurveBy') {
          ctx.bezierCurveTo(tmpx + p.cpx1, tmpy + p.cpy1, tmpx + p.cpx2, tmpy + p.cpy2, x, y);
          rcpx = 2 * x - (tmpx + p.cpx2);
          rcpy = 2 * y - (tmpy + p.cpy2);
        } else if (method == 'horizontalTo' || method == 'horizontalBy') {
          ctx.lineTo(x, y);
        } else if (method == 'verticalTo' || method == 'verticalBy') {
          ctx.lineTo(x, y);
        } else if (method == 'bezierCurveShortBy' || method == 'bezierCurveShortTo') {
          ctx.bezierCurveTo(rcpx, rcpy, tmpx + p.cpx2, tmpy + p.cpy2, x, y);
          rcpx = 2 * x - (tmpx + p.cpx2);
          rcpy = 2 * y - (tmpy + p.cpy2);
        } else if (method == 'quadraticCurveShortBy' || method == 'quadraticCurveShortTo') {
          ctx.quadraticCurveTo(rcpx, rcpy, x, y);
          rcpx = 2 * x - rcpx;
          rcpy = 2 * y - rcpy;
        }
      }
      if (this.closeMode) {
        ctx.closePath();
      }
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = this.strokeColor;
      if (this.strokeMode) {
        ctx.stroke();
      }
      ctx.restore();
    }
    /**
     * @method getNodeByName
     * SVGに設定されたNode（点）オブジェクトを返す
     * */

  }, {
    key: 'getNodeByName',
    value: function getNodeByName(name) {
      var path = this.path;
      for (var _i21 = 0, _n14 = path.length; _i21 < _n14; _i21++) {
        var p = path[_i21];
        if (name == p.name) {
          return p;
        }
      }
      return -1;
    }
  }]);

  return Shape;
}(Thing);
/**
 * @class Atlas.Shape.Box
 * @extends Atlas.Thing
 * 四角形を描画するためのクラス
 * */


var Box = exports.Box = function (_Thing2) {
  _inherits(Box, _Thing2);

  function Box(col, width, height) {
    _classCallCheck(this, Box);

    var _this4 = _possibleConstructorReturn(this, (Box.__proto__ || Object.getPrototypeOf(Box)).call(this, width, height));

    _this4._basicConstructor = 'Shape.Box';
    _this4.color = col;
    return _this4;
  }

  _createClass(Box, [{
    key: 'draw',
    value: function draw() {
      var ctx = this.ctx;
      ctx.globalAlpha = this.alpha;
      ctx.globalCompositeOperation = this.drawMode;
      ctx.beginPath();
      ctx.fillStyle = this.color;
      var x = this._x || this.x;
      var y = this._y || this.y;
      var rot = this._rot || this.rot;
      var width = this._width || this.width;
      var height = this._height || this.height;
      var moveX = x + this.width / 2;
      var moveY = y + this.height / 2;
      ctx.save();
      ctx.translate(moveX, moveY);
      ctx.rotate(rot);
      ctx.translate(-moveX, -moveY);
      var x = this._x || this.x;
      var y = this._y || this.y;
      ctx.fillRect(x, y, width, height);
      ctx.restore();
      ctx.globalAlpha = 1;
    }
  }]);

  return Box;
}(Thing);
/**
 * @class Atlas.Shape.Circle
 * @extends Atlas.Thing
 * 円を描画するためのクラス
 * */


var Circle = exports.Circle = function (_Thing3) {
  _inherits(Circle, _Thing3);

  function Circle(col, radius) {
    _classCallCheck(this, Circle);

    var _this5 = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, radius * 2, radius * 2));

    _this5._basicConstructor = 'Shape.Circle';
    _this5.color = col;
    _this5.collisionShape = 'circle';
    return _this5;
  }

  _createClass(Circle, [{
    key: 'draw',
    value: function draw() {
      var ctx = this.ctx;
      ctx.globalAlpha = this.alpha;
      ctx.globalCompositeOperation = this.drawMode;
      ctx.beginPath();
      ctx.fillStyle = this.color;
      var width = this._width || this.width;
      var plus = width / 2;
      var x = this._x || this.x;
      var y = this._y || this.y;
      ctx.arc(x + plus, y + plus, plus, 0, Math.PI * 2, false);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }]);

  return Circle;
}(Thing);
/**
 * @class Atlas.Sprite
 * @extends Atlas.Thing
 * 画像等を描画するクラス
 * */


var Sprite = exports.Sprite = function (_Thing4) {
  _inherits(Sprite, _Thing4);

  function Sprite(name) {
    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, Sprite);

    var _this6 = _possibleConstructorReturn(this, (Sprite.__proto__ || Object.getPrototypeOf(Sprite)).call(this, width, height));

    _this6.setImage(name, width, height);
    _this6._basicConstructor = 'Sprite';
    _this6.frame = 0;
    _this6.alpha = 1;
    return _this6;
  }
  /**
   * @method animate
   * フレームを変えてスプライトをアニメーションさせる
   * */


  _createClass(Sprite, [{
    key: 'animate',
    value: function animate(array, frameRate, frame) {
      var obj = Tween(this, 'animate', frame);
      obj.array = array;
      obj.frameRate = frameRate;
      obj.frameIdx = 0;
      this.mover.push(obj);
      return this;
    }
  }, {
    key: '_animate',
    value: function _animate(obj) {
      if (obj.time == 0) {
        this.frame = obj.array[0];
      }
      if (obj.time % obj.frameRate == 0) {
        obj.frameIdx = (obj.frameIdx + 1) % obj.array.length;
        this.frame = obj.array[obj.frameIdx];
      }
    }
  }, {
    key: 'setSpriteSize',
    value: function setSpriteSize(width, height) {
      this.spriteWidth = width;
      this.spriteHeight = height;
    }
  }, {
    key: 'setImage',
    value: function setImage(name, width, height) {
      if (width && height) {
        this.setSpriteSize(width, height);
      }
      var length = images.length;
      for (var _i22 = 0; _i22 < length; _i22++) {
        if (images[_i22].name == name) {
          this.img = _i22;
        }
      }
    }
  }, {
    key: 'getImage',
    value: function getImage() {
      return images[this.img];
    }
  }, {
    key: 'isLoaded',
    value: function isLoaded() {
      var image = this.getImage();
      if (image.loaded && this.ctx) {
        return true;
      }
      return false;
    }
  }, {
    key: '_onLoad',
    value: function _onLoad() {
      var obj = this.getImageSize();
      if (!this.width && obj.width) {
        this.setSpriteSize(obj.width, obj.height);
        if (!this.width) {
          this.setSize(obj.width, obj.height);
          if (this._scaleX) {
            this.scale(this._scaleX, this._scaleY);
          }
        }
      }
      this.prepared = true;
    }
  }, {
    key: 'getImageSize',
    value: function getImageSize() {
      var obj = {};
      var img = images[this.img];
      obj.width = img.width;
      obj.height = img.height;
      return obj;
    }
  }, {
    key: 'draw',
    value: function draw() {
      var ctx = this.ctx;
      ctx.globalAlpha = this.alpha;
      ctx.globalCompositeOperation = this.drawMode;
      var frame = this.frame;
      var image = images[this.img];
      var SizeX = this.spriteWidth;
      var SizeY = this.spriteHeight;
      var width = this._width || this.width;
      var height = this._height || this.height;
      var cX = width / 2;
      var cY = height / 2;
      var numX = image.width / SizeX;
      var numY = image.height / SizeY;
      var scaleX = width / SizeX;
      var scaleY = height / SizeY;
      var dx = frame % numX * SizeX;
      var dy = ~~(frame / numX) % numY * SizeY;
      var x = this._x || this.x;
      var y = this._y || this.y;
      var rot = this._rot || this.rot;
      ctx.save();
      ctx.translate(x + cX, y + cY);
      ctx.rotate(rot);
      ctx.translate(-cX, -cY);
      ctx.scale(scaleX, scaleY);
      if (dx != null) {
        ctx.drawImage(image, dx, dy, SizeX, SizeY, 0, 0, SizeX, SizeY);
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }
  }]);

  return Sprite;
}(Thing);
/**
 * @class Atlas.Map
 * @extends Atlas.Sprite
 * */


var Map = exports.Map = function (_Sprite) {
  _inherits(Map, _Sprite);

  function Map(name, width, height) {
    _classCallCheck(this, Map);

    var _this7 = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, name, width, height));

    _this7.drawData;
    _this7.hitData;
    return _this7;
  }

  _createClass(Map, [{
    key: 'intersect',
    value: function intersect(ex, ey) {
      var array = this.hitData;
      var x = array[0].length;
      var y = array.length;
      var width = this._width || this.width;
      var height = this._height || this.height;
      var posX = this._x || this.x;
      var posY = this._y || this.y;
      for (var _i23 = 0; _i23 < y; _i23++) {
        for (var t = 0; t < x; t++) {
          if (array[_i23][t] == 1 && posX + t * width < ex && ex < posX + (t + 1) * width && posY + _i23 * height < ey && ey < posY + (_i23 + 1) * height) {
            return true;
          }
        }
      }
      return false;
    }
  }, {
    key: 'draw',
    value: function draw() {
      var array = this.drawData;
      if (array && array[0]) {
        var x = array[0].length;
        var y = array.length;
        var width = this._width || this.width;
        var height = this._height || this.height;
        var px = this._x || this.x;
        var py = this._y || this.y;
        var _i24 = 0;
        var t = 0;
        var field = this.field;
        var ctx = this.ctx;
        ctx.globalAlpha = this.alpha;
        ctx.globalCompositeOperation = this.drawMode;
        var fieldHeight = field.height;
        var fieldWidth = field.width;
        var frame = void 0;
        var image = images[this.img];
        var SizeX = this.spriteWidth;
        var SizeY = this.spriteHeight;
        var cX = width / 2;
        var cY = height / 2;
        var numX = image.width / SizeX;
        var numY = image.height / SizeY;
        var scaleX = this.width / SizeX;
        var scaleY = this.height / SizeY;
        var posX = px;
        var posY = py;
        while (_i24 < y) {
          while (t < x) {
            frame = array[_i24][t];
            if (frame >= 0 && fieldHeight > py + height * _i24 && py + height * (_i24 + 1) > 0 && fieldWidth > px + width * t && px + width * (t + 1) > 0) {
              var dx = frame % numX * SizeX;
              var dy = ~~(frame / numX) % numY * SizeY;
              ctx.save();
              ctx.translate(posX, posY);
              ctx.scale(scaleX, scaleY);
              ctx.drawImage(image, dx, dy, SizeX, SizeY, 0, 0, SizeX, SizeY);
              ctx.restore();
            }
            posX += width;
            t++;
          }
          posY += height;
          posX = px;
          _i24++;
          t = 0;
        }
      }
    }
  }]);

  return Map;
}(Sprite);
/**
 * @class Atlas.Text
 * @extends Atlas.Util
 * */


var Text = exports.Text = function (_Util3) {
  _inherits(Text, _Util3);

  function Text(string, col, size, font) {
    _classCallCheck(this, Text);

    var _this8 = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this));

    _this8._basicConstructor = 'Text';
    _this8.x = 0;
    _this8.y = 0;
    _this8.scaleX = 1;
    _this8.scaleY = 1;
    _this8.alpha = 1;
    _this8.spaceWidth = 7; /* append */
    if (font) {
      _this8.font = '\'' + font + '\'';
    } else {
      _this8.font = "'Meiryo'";
    }
    if (size) {
      _this8.size = size + 'px';
    } else {
      _this8.size = '10px';
    }
    if (string) {
      _this8.string = string;
    } else {
      _this8.string = '';
    }
    if (col) {
      _this8.color = col;
    } else {
      _this8.color = 'white';
    }
    return _this8;
  }

  _createClass(Text, [{
    key: 'setSize',
    value: function setSize(size) {
      this.size = size + 'px';
    }
  }, {
    key: 'setFont',
    value: function setFont(font) {
      this.font = '\'' + font + '\'';
    }
  }, {
    key: 'intersect',
    value: function intersect(ex, ey) {
      var thisx = this._x || this.x;
      var thisy = this._y || this.y;
      var width = parseInt(this.size) * this.scaleX * this.string.length;
      var height = parseInt(this.size) * this.scaleY;
      var x = ex - (thisx + width / 2);
      var y = ey - (thisy + height / 2);
      var r = this._rot || this.rot;
      var s = Math.sin(-r);
      var c = Math.cos(-r);
      var xx = Math.abs(x * c - y * s);
      var yy = Math.abs(x * s + y * c);
      if (xx < width / 2.0 && yy < height / 2.0) {
        return true;
      }
      return false;
    }
  }, {
    key: 'scale',
    value: function scale(x, y) {
      this.scaleX *= x;
      this.scaleY *= y;
    }
  }, {
    key: '_scaleBy',
    value: function _scaleBy(obj) {
      if (obj.time == 0) {
        obj.diffWidth = obj.scaleX - this.scaleX;
        obj.diffHeight = obj.scaleY - this.scaleY;
      }
      this.scaleX = obj.scaleX - obj.diffWidth * (1 - obj.time / obj.frame);
      this.scaleY = obj.scaleY - obj.diffHeight * (1 - obj.time / obj.frame);
    }
  }, {
    key: 'draw',
    value: function draw() {
      var x = this._x || this.x;
      var y = this._y || this.y;
      var rot = this._rot || this.rot;
      var scaleX = this.scaleX;
      var scaleY = this.scaleY;
      var ctx = this.ctx;
      var strings = this.string.split('<br>');
      var length = strings.length;
      ctx.globalAlpha = this.alpha;
      ctx.globalCompositeOperation = this.drawMode;
      ctx.font = this.size + ' ' + this.font;
      var height = ctx.measureText('a').width * 1.5 + this.spaceWidth;
      ctx.fillStyle = this.color;
      ctx.save();
      var cX = parseInt(this.size) * this.scaleX * this.string.length / 2;
      var cY = parseInt(this.size) * this.scaleY / 2;
      ctx.translate(x + cX, y + cY);
      ctx.rotate(rot);
      ctx.translate(-cX, -cY);
      ctx.scale(scaleX, scaleY);
      for (var _i25 = 0; _i25 < length; _i25++) {
        ctx.fillText(strings[_i25], 0, height);
        height *= 2;
      }
      ctx.restore();
      ctx.globalAlpha = 1;
    }
  }]);

  return Text;
}(Util);
/**
 * @class Atlas.Group
 * @extends Atlas.Thing
 * */


var Group = exports.Group = function (_Thing5) {
  _inherits(Group, _Thing5);

  function Group() {
    _classCallCheck(this, Group);

    var _this9 = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this));

    _this9.children = [];
    _this9.x = 0;
    _this9.y = 0;
    _this9._basicConstructor = 'Group';
    return _this9;
  }

  _createClass(Group, [{
    key: 'addChild',
    value: function addChild(sprite) {
      sprite.parent = this;
      this.children.push(sprite);
      if (this.parent) {
        sprite.ctx = this.parent.ctx;
        sprite.field = this.parent.field;
        this.parent.children.push(sprite);
      }
    }
  }, {
    key: 'addChildren',
    value: function addChildren() {
      for (var _i26 = 0, _n15 = arguments.length; _i26 < _n15; _i26++) {
        this.addChild(arguments[_i26]);
      }
    }
  }, {
    key: 'getChild',
    value: function getChild(obj) {
      var array = this.getChildren(obj);
      var ret = array[0];
      if (!ret) {
        ret = null;
      }
      return ret;
    }
  }, {
    key: 'getChildren',
    value: function getChildren(obj) {
      var ret = [];
      var children = this.children;
      for (var _i27 = 0, _n16 = children.length; _i27 < _n16; _i27++) {
        var flag = true;
        for (var key in obj) {
          if (key == '$not') {
            for (var key2 in obj.$not) {
              if (obj.$not[key2] == children[_i27][key2]) {
                flag = false;
              }
            }
          } else if (obj[key] != children[_i27][key]) {
            flag = false;
          }
        }
        if (flag == true) {
          ret.push(children[_i27]);
        }
      }
      return ret;
    }
  }, {
    key: 'removeChild',
    value: function removeChild(obj) {
      var child = this.getChild(obj);
      child.remove();
    }
  }, {
    key: 'removeChildren',
    value: function removeChildren(obj) {
      var children = this.getChildren(obj);
      for (var _i28 = 0, _n17 = children.length; _i28 < _n17; _i28++) {
        children[_i28].remove();
      }
    }
  }, {
    key: 'draw',
    value: function draw() {}
  }]);

  return Group;
}(Thing);
/**
 * @class Atlas.Scene
 * @extends Atlas.Group
 * */


var Scene = exports.Scene = function (_Group) {
  _inherits(Scene, _Group);

  function Scene() {
    _classCallCheck(this, Scene);

    var _this10 = _possibleConstructorReturn(this, (Scene.__proto__ || Object.getPrototypeOf(Scene)).call(this));

    _this10._basicConstructor = 'Scene';
    _this10._remove = false;
    return _this10;
  }

  _createClass(Scene, [{
    key: 'addChild',
    value: function addChild(sprite) {
      sprite.parent = this;
      if (this.ctx && this.field) {
        sprite.ctx = this.ctx;
        sprite.field = this.field;
      }
      this.children.push(sprite);
      if (sprite._basicConstructor == 'Group' || sprite._basicConstructor == 'Layer') {
        var children = sprite.children;
        for (var _i29 = 0, _n18 = children.length; _i29 < _n18; _i29++) {
          var child = children[_i29];
          if (!child.ctx) {
            child.ctx = this.ctx;
            child.field = this.field;
            this.children.push(child);
          }
        }
      }
    }
  }, {
    key: 'setImage',
    value: function setImage(image) {
      this.image = image;
    }
  }, {
    key: 'setColor',
    value: function setColor(color) {
      this.color = color;
    }
  }, {
    key: '_enterFrame',
    value: function _enterFrame(e) {
      if (this.enterFrame) {
        this.enterFrame();
      }
      var children = this.children;
      for (var _i30 = 0, _n19 = children.length; _i30 < _n19; _i30++) {
        var target = children[_i30];
        if (target._remove) {
          children.splice(_i30, 1);
          target = null;
          _i30--;
          _n19--;
          continue;
        }
        if (target._basicConstructor == 'Sprite' || target._basicConstructor == 'Map' || target._basicConstructor == 'Shape') {
          if (target.isLoaded() && !target.prepared) {
            target._onLoad();
            if (target.onLoad) {
              /* フックを登録していたら */
              target.onLoad();
            }
          }
        } /* ロードが終わったオブジェクトの描画準備を完了させる */
        if (target.useEvent) {
          target.useEvent();
        }
        if (target._enterFrame) {
          target._enterFrame();
        }
        if (target.enterFrame) {
          target.enterFrame();
        }
        if (target.tween) {
          target.tween();
        }
        if (target.visible) {
          target.draw();
        }
      }
    }
  }]);

  return Scene;
}(Group);
/**
 * @class Atlas.Layer
 * @extends Atlas.Group
 * */


var Layer = exports.Layer = function (_Group2) {
  _inherits(Layer, _Group2);

  function Layer() {
    _classCallCheck(this, Layer);

    var _this11 = _possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).call(this));

    _this11.rot = 0;
    _this11._basicConstructor = 'Layer';
    _this11.firstWidth = 100;
    _this11.firstHeight = 100;
    _this11.height = 100;
    _this11.width = 100;
    _this11.scaleX = 1;
    _this11.scaleY = 1;
    return _this11;
  }
  /**
   * @method fitToChildren
   * 登録されたオブジェクトが占める矩形幅にレイヤーのサイズを合わせる
   * */


  _createClass(Layer, [{
    key: 'fitToChildren',
    value: function fitToChildren() {
      var children = this.children;
      var postx = this.x;
      var posty = this.y;
      this.x = null;
      this.y = null;
      this.width = 0;
      this.height = 0;
      for (var _i31 = 0, _n20 = children.length; _i31 < _n20; _i31++) {
        var child = children[_i31];
        var x = child._x || child.x;
        var y = child._y || child.y;
        var width = child._width || child.width;
        var height = child._height || child.height;
        var centerX = x + width / 2;
        var centerY = y + height / 2;
        var rot = child._rot || child.rot;
        rot %= 2 * Math.PI;
        if (rot < 0) {
          rot += 2 * Math.PI;
        }
        if (rot >= 0 && rot <= Math.PI / 2) {
          var x1 = Math.cos(rot) * (x - centerX) - Math.sin(rot) * (y + height - centerY) + centerX;
          var x2 = Math.cos(rot) * (x + width - centerX) - Math.sin(rot) * (y - centerY) + centerX;
          var y1 = Math.sin(rot) * (x - centerX) + Math.cos(rot) * (y - centerY) + centerY;
          var y2 = Math.sin(rot) * (x + width - centerX) + Math.cos(rot) * (y + height - centerY) + centerY;
        } else if (Math.PI / 2 < rot && rot <= Math.PI) {
          var x1 = Math.cos(rot) * (x + width - centerX) - Math.sin(rot) * (y + height - centerY) + centerX;
          var x2 = Math.cos(rot) * (x - centerX) - Math.sin(rot) * (y - centerY) + centerX;
          var y1 = Math.sin(rot) * (x - centerX) + Math.cos(rot) * (y + height - centerY) + centerY;
          var y2 = Math.sin(rot) * (x + width - centerX) + Math.cos(rot) * (y - centerY) + centerY;
        } else if (Math.PI < rot && rot <= 3 / 2 * Math.PI) {
          var x1 = Math.cos(rot) * (x + width - centerX) - Math.sin(rot) * (y - centerY) + centerX;
          var x2 = Math.cos(rot) * (x - centerX) - Math.sin(rot) * (y + height - centerY) + centerX;
          var y1 = Math.sin(rot) * (x + width - centerX) + Math.cos(rot) * (y + height - centerY) + centerY;
          var y2 = Math.sin(rot) * (x - centerX) + Math.cos(rot) * (y - centerY) + centerY;
        } else if (3 / 2 * Math.PI < rot && rot <= 2 * Math.PI) {
          var x1 = Math.cos(rot) * (x - centerX) - Math.sin(rot) * (y - centerY) + centerX;
          var x2 = Math.cos(rot) * (x + width - centerX) - Math.sin(rot) * (y + height - centerY) + centerX;
          var y1 = Math.sin(rot) * (x + width - centerX) + Math.cos(rot) * (y - centerY) + centerY;
          var y2 = Math.sin(rot) * (x - centerX) + Math.cos(rot) * (y + height - centerY) + centerY;
        }
        if (!this.x || this.x > x1) {
          this.x = x1;
        }
        if (!this.y || this.y > y1) {
          this.y = y1;
        }
        if (this.width < x2) {
          this.width = x2;
        }
        if (this.height < y2) {
          this.height = y2;
        }
      }
      this.width -= this.x;
      this.height -= this.y;
      this.firstWidth = this.width;
      this.firstHeight = this.height;
      for (var _i32 = 0, _n21 = children.length; _i32 < _n21; _i32++) {
        var child = children[_i32];
        if (!child._x) {
          child._x = child.x;
          child._y = child.y;
          child.x -= this.x;
          child.y -= this.y;
        } else {
          child.x += postx - this.x;
          child.y += posty - this.y;
        }
      }
      return this;
    }
    /**
     * @method releaseChild
     * @param child Atlas.Thingクラス
     * 登録されているオブジェクトを解放する
     * */

  }, {
    key: 'releaseChild',
    value: function releaseChild(child) {
      var parent = this.parent;
      child.x = child._x;
      child.y = child._y;
      child.width = child._width;
      child.height = child._height;
      child.rot = child._rot;
      child._x = null;
      child._y = null;
      child._width = null;
      child._height = null;
      child._rot = null;
      child.grouped = false;
      child._leave = false;
      child.parent = parent;
    }
    /**
     * @method releaseAllChildren
     * 登録されているすべてのオブジェクトを解放する
     * */

  }, {
    key: 'releaseAllChildren',
    value: function releaseAllChildren() {
      var children = this.children;
      for (var _i33 = 0, _n22 = children.length; _i33 < _n22; _i33++) {
        var child = children[_i33];
        this.releaseChild(child);
      }
      this.children = [];
      this._remove = true;
      return this;
    }
    /**
     * @method removeChildrenByProperty
     * @param obj Object
     * プロパティの値が一致するオブジェクトを削除する
     * */

  }, {
    key: 'removeChildrenByProperty',
    value: function removeChildrenByProperty(obj) {
      var children = this.getChildren(obj);
      for (var _i34 = 0, _n23 = children.length; _i34 < _n23; _i34++) {
        children[_i34].remove();
      }
      return this;
    }
    /**
     * @method removeAllChildren
     * 登録されたすべてのオブジェクトを削除する
     * */

  }, {
    key: 'removeAllChildren',
    value: function removeAllChildren() {
      var children = this.children;
      var parent = this.parent;
      for (var _i35 = 0, _n24 = children.length; _i35 < _n24; _i35++) {
        children[_i35].remove();
      }
      return this;
    }
  }, {
    key: '_setAbsPos',
    value: function _setAbsPos(child) {
      var centerX = this.width / 2;
      var centerY = this.height / 2;
      var rot = this.rot;
      child.Cx = this.scaleX * child.x + child._width / 2;
      child.Cy = this.scaleY * child.y + child._height / 2;
      child.startRot = true;
      var cx = Math.cos(rot) * (child.Cx - centerX) - Math.sin(rot) * (child.Cy - centerY) + centerX; // this.width/2
      var cy = Math.sin(rot) * (child.Cx - centerX) + Math.cos(rot) * (child.Cy - centerY) + centerY; // this.height/2
      child._x = cx - child._width / 2;
      child._y = cy - child._height / 2;
      child._x += this.x;
      child._y += this.y;
    }
  }, {
    key: 'draw',
    value: function draw() {
      var children = this.children;
      this.scaleX = this.width / this.firstWidth;
      this.scaleY = this.height / this.firstHeight;
      for (var _i36 = 0, _n25 = children.length; _i36 < _n25; _i36++) {
        var target = children[_i36];
        if (target._leave || target._remove) {
          children.splice(_i36, 1);
          this.releaseChild(target);
          _i36--;
          _n25--;
          continue;
        }
        target._rot = target.rot + this.rot;
        target._width = this.scaleX * target.width;
        target._height = this.scaleY * target.height;
        this._setAbsPos(target);
      }
    }
  }]);

  return Layer;
}(Group);

},{}]},{},[1])(1)
});
